<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.29">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kevin Markham">
<meta name="description" content="A practical guide to help you transform from Machine Learning novice to skilled Machine Learning practitioner.">

<title>3&nbsp; Encoding categorical features – Master Machine Learning with scikit-learn</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./ch04.html" rel="next">
<link href="./ch02.html" rel="prev">
<link href="./favicon.png" rel="icon" type="image/png">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-0815c480559380816a4d1ea211a47e91.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e32d5626311174d9f6538aca58dc36c7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://cdn.usefathom.com/script.js" data-site="AWKMQOCB" defer=""></script>


<meta property="og:title" content="3&nbsp; Encoding categorical features – Master Machine Learning with scikit-learn">
<meta property="og:description" content="">
<meta property="og:image" content="https://mlbook.dataschool.io/logo.png">
<meta property="og:site_name" content="Master Machine Learning with scikit-learn">
<meta property="og:image:height" content="141">
<meta property="og:image:width" content="266">
<meta name="twitter:title" content="3&nbsp; Encoding categorical features – Master Machine Learning with scikit-learn">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://mlbook.dataschool.io/logo.png">
<meta name="twitter:image-height" content="141">
<meta name="twitter:image-width" content="266">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./ch03.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Encoding categorical features</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Master Machine Learning with scikit-learn</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About this book</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Review of the Machine Learning workflow</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch03.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Encoding categorical features</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Improving your workflow with ColumnTransformer and Pipeline</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Workflow review #1</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch06.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Encoding text data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch07.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Handling missing values</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch08.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Fixing common workflow problems</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch09.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Workflow review #2</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Evaluating and tuning a Pipeline</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch11.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Comparing linear and non-linear models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch12.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Ensembling multiple models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch13.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Feature selection</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch14.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">Feature standardization</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch15.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">Feature engineering with custom transformers</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch16.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">16</span>&nbsp; <span class="chapter-title">Workflow review #3</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch17.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">17</span>&nbsp; <span class="chapter-title">High-cardinality categorical features</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch18.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">18</span>&nbsp; <span class="chapter-title">Class imbalance</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch19.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">19</span>&nbsp; <span class="chapter-title">Class imbalance walkthrough</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./ch20.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">20</span>&nbsp; <span class="chapter-title">Going further</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction-to-one-hot-encoding" id="toc-introduction-to-one-hot-encoding" class="nav-link active" data-scroll-target="#introduction-to-one-hot-encoding"><span class="header-section-number">3.1</span> Introduction to one-hot encoding</a></li>
  <li><a href="#transformer-methods-fit-transform-fit_transform" id="toc-transformer-methods-fit-transform-fit_transform" class="nav-link" data-scroll-target="#transformer-methods-fit-transform-fit_transform"><span class="header-section-number">3.2</span> Transformer methods: fit, transform, fit_transform</a></li>
  <li><a href="#one-hot-encoding-of-multiple-features" id="toc-one-hot-encoding-of-multiple-features" class="nav-link" data-scroll-target="#one-hot-encoding-of-multiple-features"><span class="header-section-number">3.3</span> One-hot encoding of multiple features</a></li>
  <li><a href="#qa-when-should-i-use-transform-instead-of-fit_transform" id="toc-qa-when-should-i-use-transform-instead-of-fit_transform" class="nav-link" data-scroll-target="#qa-when-should-i-use-transform-instead-of-fit_transform"><span class="header-section-number">3.4</span> Q&amp;A: When should I use transform instead of fit_transform?</a></li>
  <li><a href="#sec-3-5" id="toc-sec-3-5" class="nav-link" data-scroll-target="#sec-3-5"><span class="header-section-number">3.5</span> Q&amp;A: What happens if the testing data includes a new category?</a></li>
  <li><a href="#sec-3-6" id="toc-sec-3-6" class="nav-link" data-scroll-target="#sec-3-6"><span class="header-section-number">3.6</span> Q&amp;A: Should I drop one of the one-hot encoded categories?</a></li>
  <li><a href="#qa-how-do-i-encode-an-ordinal-feature" id="toc-qa-how-do-i-encode-an-ordinal-feature" class="nav-link" data-scroll-target="#qa-how-do-i-encode-an-ordinal-feature"><span class="header-section-number">3.7</span> Q&amp;A: How do I encode an ordinal feature?</a></li>
  <li><a href="#qa-whats-the-difference-between-ordinalencoder-and-labelencoder" id="toc-qa-whats-the-difference-between-ordinalencoder-and-labelencoder" class="nav-link" data-scroll-target="#qa-whats-the-difference-between-ordinalencoder-and-labelencoder"><span class="header-section-number">3.8</span> Q&amp;A: What’s the difference between OrdinalEncoder and LabelEncoder?</a></li>
  <li><a href="#qa-should-i-encode-numeric-features-as-ordinal-features" id="toc-qa-should-i-encode-numeric-features-as-ordinal-features" class="nav-link" data-scroll-target="#qa-should-i-encode-numeric-features-as-ordinal-features"><span class="header-section-number">3.9</span> Q&amp;A: Should I encode numeric features as ordinal features?</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Encoding categorical features</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction-to-one-hot-encoding" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="introduction-to-one-hot-encoding"><span class="header-section-number">3.1</span> Introduction to one-hot encoding</h2>
<p>In this chapter, we’re going to focus on one of the most important data preprocessing steps, which is the encoding of categorical features.</p>
<p>Let’s take a look at our Titanic DataFrame. In the last chapter, the only features we used were Parch and Fare. In this chapter, we want to add Embarked and Sex as additional features, in case they improve our model.</p>
<div id="d983e2db" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Survived</th>
<th data-quarto-table-cell-role="th">Pclass</th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Sex</th>
<th data-quarto-table-cell-role="th">Age</th>
<th data-quarto-table-cell-role="th">SibSp</th>
<th data-quarto-table-cell-role="th">Parch</th>
<th data-quarto-table-cell-role="th">Ticket</th>
<th data-quarto-table-cell-role="th">Fare</th>
<th data-quarto-table-cell-role="th">Cabin</th>
<th data-quarto-table-cell-role="th">Embarked</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>0</td>
<td>3</td>
<td>Braund, Mr. Owen Harris</td>
<td>male</td>
<td>22.0</td>
<td>1</td>
<td>0</td>
<td>A/5 21171</td>
<td>7.2500</td>
<td>NaN</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1</td>
<td>1</td>
<td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>
<td>female</td>
<td>38.0</td>
<td>1</td>
<td>0</td>
<td>PC 17599</td>
<td>71.2833</td>
<td>C85</td>
<td>C</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1</td>
<td>3</td>
<td>Heikkinen, Miss. Laina</td>
<td>female</td>
<td>26.0</td>
<td>0</td>
<td>0</td>
<td>STON/O2. 3101282</td>
<td>7.9250</td>
<td>NaN</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1</td>
<td>1</td>
<td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>
<td>female</td>
<td>35.0</td>
<td>1</td>
<td>0</td>
<td>113803</td>
<td>53.1000</td>
<td>C123</td>
<td>S</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0</td>
<td>3</td>
<td>Allen, Mr. William Henry</td>
<td>male</td>
<td>35.0</td>
<td>0</td>
<td>0</td>
<td>373450</td>
<td>8.0500</td>
<td>NaN</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>0</td>
<td>3</td>
<td>Moran, Mr. James</td>
<td>male</td>
<td>NaN</td>
<td>0</td>
<td>0</td>
<td>330877</td>
<td>8.4583</td>
<td>NaN</td>
<td>Q</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>0</td>
<td>1</td>
<td>McCarthy, Mr. Timothy J</td>
<td>male</td>
<td>54.0</td>
<td>0</td>
<td>0</td>
<td>17463</td>
<td>51.8625</td>
<td>E46</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>0</td>
<td>3</td>
<td>Palsson, Master. Gosta Leonard</td>
<td>male</td>
<td>2.0</td>
<td>3</td>
<td>1</td>
<td>349909</td>
<td>21.0750</td>
<td>NaN</td>
<td>S</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8</td>
<td>1</td>
<td>3</td>
<td>Johnson, Mrs. Oscar W (Elisabeth Vilhelmina Berg)</td>
<td>female</td>
<td>27.0</td>
<td>0</td>
<td>2</td>
<td>347742</td>
<td>11.1333</td>
<td>NaN</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">9</td>
<td>1</td>
<td>2</td>
<td>Nasser, Mrs. Nicholas (Adele Achem)</td>
<td>female</td>
<td>14.0</td>
<td>1</td>
<td>0</td>
<td>237736</td>
<td>30.0708</td>
<td>NaN</td>
<td>C</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>As a reminder, Parch is the number of parents or children aboard with that passenger, and Fare is the amount the passenger paid. Our first new feature, Embarked, is the port that each passenger embarked from, and the possible values are C, Q, or S. Our other new feature, Sex, is simply male or female.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Currently selected features:</strong></p>
<ul>
<li><strong>Parch:</strong> Number of parents or children aboard with that passenger</li>
<li><strong>Fare:</strong> Amount the passenger paid</li>
<li><strong>Embarked:</strong> Port the passenger embarked from</li>
<li><strong>Sex:</strong> Male or female</li>
</ul>
</div>
</div>
</div>
<p>Both Embarked and Sex are known as unordered categorical features because there are distinct categories and there’s no inherent logical ordering to the categories. This type of data is also known as nominal data.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Unordered categorical data:</strong></p>
<ul>
<li>Contains distinct categories</li>
<li>No inherent logical ordering to the categories</li>
<li>Also called “nominal data”</li>
</ul>
</div>
</div>
</div>
<p>All scikit-learn models expect features to be numeric, and so Embarked and Sex can’t actually be passed directly to a model. Instead, we’re going to encode them using a process called one-hot encoding, also known as dummy encoding.</p>
<p>Let’s look at the code for one-hot encoding. First, we import the <code>OneHotEncoder</code> class from the <code>preprocessing</code> module. Then, we create an instance of it and set <code>sparse</code> to <code>False</code>.</p>
<div id="7c9cb7ce" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> OneHotEncoder</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>ohe <span class="op">=</span> OneHotEncoder(sparse<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>By default, <code>OneHotEncoder</code> will output a sparse matrix, which is the most efficient and performant data structure for this type of data. By setting <code>sparse</code> to <code>False</code>, it will instead output a dense matrix, which is just the normal (human-readable) way of representing a matrix. This representation will allow us to examine the output so that we can understand the encoding scheme.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Matrix representations:</strong></p>
<ul>
<li><strong>Sparse:</strong> More efficient and performant</li>
<li><strong>Dense:</strong> More readable</li>
</ul>
</div>
</div>
</div>
<p>Next, we’ll encode the Embarked column by passing it to the <code>fit_transform</code> method of the <code>OneHotEncoder</code>. We’ll talk about the <code>fit_transform</code> method in the next lesson, but for now I just want to highlight that we’ll use double brackets around Embarked to pass it as a single-column DataFrame instead of using single brackets to pass it as a Series.</p>
<p>This is important because <code>OneHotEncoder</code> expects to receive a two-dimensional object (such as a DataFrame) since a one-dimensional object is considered ambiguous. A one-dimensional Series could be interpreted either as a single feature or a single sample, whereas our two-dimensional DataFrame signals to scikit-learn that this is indeed a single feature.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Why use double brackets?</strong></p>
<ul>
<li><strong>Single brackets:</strong>
<ul>
<li>Outputs a Series</li>
<li>Could be interpreted as a single feature or a single sample</li>
</ul></li>
<li><strong>Double brackets:</strong>
<ul>
<li>Outputs a single-column DataFrame</li>
<li>Interpreted as a single feature</li>
</ul></li>
</ul>
</div>
</div>
</div>
<p>Running the <code>fit_transform</code> method outputs this 10 by 3 array. This is the encoded version of the Embarked column, and it is exactly what we will pass to the model instead of the strings C, Q, and S.</p>
<div id="87420c84" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>ohe.fit_transform(df[[<span class="st">'Embarked'</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<pre><code>array([[0., 0., 1.],
       [1., 0., 0.],
       [0., 0., 1.],
       [0., 0., 1.],
       [0., 0., 1.],
       [0., 1., 0.],
       [0., 0., 1.],
       [0., 0., 1.],
       [0., 0., 1.],
       [1., 0., 0.]])</code></pre>
</div>
</div>
<p>Let’s talk about how we interpret this output. There are 3 columns because there were 3 unique values in Embarked. Each row contains a single 1, and the rest of the values in the row are 0. 100 means “C”, 010 means “Q”, and 001 means “S”, which you can confirm by comparing it to the Embarked column in our DataFrame.</p>
<p>As an aside, this is called one-hot encoding because in each row there is one “hot” level, meaning one non-zero level.</p>
<p>This is also the same output you would get by using the <code>get_dummies</code> function in pandas, though we’ll talk later in the book why it’s best to do all of your preprocessing in scikit-learn instead of pandas.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Output of OneHotEncoder:</strong></p>
<ul>
<li>One column for each unique value</li>
<li>One non-zero value in each row:
<ul>
<li>1, 0, 0 means “C”</li>
<li>0, 1, 0 means “Q”</li>
<li>0, 0, 1 means “S”</li>
</ul></li>
</ul>
</div>
</div>
</div>
<p>Let’s now look at the <code>categories_</code> attribute of the <code>OneHotEncoder</code>. You can think of it as the column header for our 10 by 3 array. In other words, the <code>categories_</code> attribute tells you that the first column represents “C”, the second column represents “Q”, and the third column represents “S”. Because the categories are always in alphabetical order from left to right, I didn’t actually have to examine the <code>categories_</code> attribute in order to know how to interpret the array.</p>
<p>As an aside, you’ll notice a lot of attributes in scikit-learn end in an <code>_</code>. This is scikit-learn’s convention for any attribute that is learned or estimated from the data during the <code>fit</code> step.</p>
<div id="8a0b8619" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>ohe.categories_</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="8">
<pre><code>[array(['C', 'Q', 'S'], dtype=object)]</code></pre>
</div>
</div>
<p>We’ve now seen how the <code>OneHotEncoder</code> encodes the Embarked feature. But why is this a reasonable way to encode a categorical feature?</p>
<p>You can think of it this way: <code>OneHotEncoder</code> creates a feature from each level so that the model can learn the relationship between each level and the target value. In this case, the model can learn the relationship between the target value of Survived and whether or not a passenger embarked at a given port.</p>
<p>For example, the model might learn from the first feature that passengers who embarked at C have a higher survival rate than passengers who didn’t embark at C. This is similar to how a model might learn from a numeric feature like Fare that passengers with a higher Fare have a higher survival rate than passengers with a lower Fare.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Why use one-hot encoding?</strong></p>
<ul>
<li>Model can learn the relationship between each level and the target value</li>
<li><strong>Example:</strong> Model might learn that “C” passengers have a higher survival rate than “not C” passengers</li>
</ul>
</div>
</div>
</div>
<p>At this point, you might be wondering whether we could have instead encoded Embarked as a single numeric feature with the values 0, 1, and 2 representing C, Q, and S. The answer is “yes”, we can do this, but it’s generally not a good idea to do this with unordered categories because it would imply an ordering that doesn’t inherently exist.</p>
<p>To see why it’s not a good idea, let’s pretend that passengers who embarked at C and S had high survival rates, and passengers who embarked at Q had low survival rates. There would be no way for a linear model (like logistic regression) to learn that relationship if Embarked is encoded as a single feature. That’s because a single feature can’t be assigned both a negative coefficient to represent the impact of Q (with respect to C) and a positive coefficient to represent the impact of S (with respect to Q).</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Why not encode as a single feature?</strong></p>
<ul>
<li><strong>Pretend:</strong>
<ul>
<li><strong>C:</strong> high survival rate</li>
<li><strong>Q:</strong> low survival rate</li>
<li><strong>S:</strong> high survival rate</li>
</ul></li>
<li><strong>Single feature would need two coefficients:</strong>
<ul>
<li>Negative coefficient for impact of Q (with respect to C)</li>
<li>Positive coefficient for impact of S (with respect to Q)</li>
</ul></li>
</ul>
</div>
</div>
</div>
<p>In summary, encoding Embarked as a single feature would prohibit a linear model from learning a non-linear relationship in the data, which is why encoding it as multiple features is generally the better choice.</p>
</section>
<section id="transformer-methods-fit-transform-fit_transform" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="transformer-methods-fit-transform-fit_transform"><span class="header-section-number">3.2</span> Transformer methods: fit, transform, fit_transform</h2>
<p>Let’s discuss the <code>fit_transform</code> method, since that’s the method we used with <code>OneHotEncoder</code> to encode the Embarked feature.</p>
<p><code>OneHotEncoder</code> is known as a transformer, meaning its role is to perform data transformations. Transformers usually have a <code>fit</code> method and always have a <code>transform</code> method. The <code>fit</code> method is when the transformer learns something, and the <code>transform</code> method is when it uses what it learned to do the data transformation.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Generic transformer methods:</strong></p>
<ul>
<li><strong><code>fit</code>:</strong> Transformer learns something</li>
<li><strong><code>transform</code>:</strong> Transformer uses what it learned to do the data transformation</li>
</ul>
</div>
</div>
</div>
<p>Using <code>OneHotEncoder</code> as an example, the <code>fit</code> method is when it learns the categories from the data in alphabetical order, and the <code>transform</code> method is when it creates the feature matrix using those categories.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>OneHotEncoder methods:</strong></p>
<ul>
<li><strong><code>fit</code>:</strong> Learn the categories</li>
<li><strong><code>transform</code>:</strong> Create the feature matrix using those categories</li>
</ul>
</div>
</div>
</div>
<p>The <code>fit_transform</code> method, which is what we used above, just combines those two steps into a single method call. You can actually do those steps as two separate calls of <code>fit</code> then <code>transform</code>, but the single method call of <code>fit_transform</code> is better because it’s more computationally efficient and also more readable (in my opinion).</p>
</section>
<section id="one-hot-encoding-of-multiple-features" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="one-hot-encoding-of-multiple-features"><span class="header-section-number">3.3</span> One-hot encoding of multiple features</h2>
<p>We saw how to use <code>OneHotEncoder</code> to encode the Embarked column, but we actually need to encode both Embarked and Sex. Thankfully, <code>OneHotEncoder</code> can be applied to multiple features at once.</p>
<p>To do this, we simply pass a two-column DataFrame to the <code>fit_transform</code> method, whereas previously we had passed a one-column DataFrame. It outputs 5 columns, in which the first 3 columns represent Embarked and the last 2 columns represent Sex.</p>
<div id="411a07d4" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>ohe.fit_transform(df[[<span class="st">'Embarked'</span>, <span class="st">'Sex'</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>array([[0., 0., 1., 0., 1.],
       [1., 0., 0., 1., 0.],
       [0., 0., 1., 1., 0.],
       [0., 0., 1., 1., 0.],
       [0., 0., 1., 0., 1.],
       [0., 1., 0., 0., 1.],
       [0., 0., 1., 0., 1.],
       [0., 0., 1., 0., 1.],
       [0., 0., 1., 1., 0.],
       [1., 0., 0., 1., 0.]])</code></pre>
</div>
</div>
<p>Looking at the <code>categories_</code> attribute, we first see the 3 categories that were learned from Embarked in alphabetical order, and then we see the 2 categories that were learned from Sex in alphabetical order. Thus, we know that a 10 in the last two columns means “female”, and a 01 in the last two columns means “male”.</p>
<div id="8555f87d" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>ohe.categories_</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>[array(['C', 'Q', 'S'], dtype=object), array(['female', 'male'], dtype=object)]</code></pre>
</div>
</div>
<p>So for example, the first sample in the output array is 00101, which means they embarked from S and they are male. The second sample in the array is 10010, which means they embarked from C and they are female. And so on.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Decoding the output array:</strong></p>
<ul>
<li><strong>First three columns:</strong>
<ul>
<li>1, 0, 0 means “C”</li>
<li>0, 1, 0 means “Q”</li>
<li>0, 0, 1 means “S”</li>
</ul></li>
<li><strong>Last two columns:</strong>
<ul>
<li>1, 0 means “female”</li>
<li>0, 1 means “male”</li>
</ul></li>
<li><strong>Example:</strong>
<ul>
<li>0, 0, 1, 0, 1 means “S, male”</li>
<li>1, 0, 0, 1, 0 means “C, female”</li>
</ul></li>
</ul>
</div>
</div>
</div>
<p>Recall that our goal in this chapter was to numerically encode Embarked and Sex so we could include them in our model along with Parch and Fare. How might we do that?</p>
<p>One idea would be to manually stack Parch and Fare side-by-side with the 5 columns output by <code>OneHotEncoder</code>, and then train the model using all 7 columns. However, we would need to repeat the same exact process of encoding and stacking with the new data, since if you train a model with 7 features, you need the same 7 features in the new data in order to make predictions.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>How to manually add Embarked and Sex to the model:</strong></p>
<ol type="1">
<li>Stack Parch and Fare side-by-side with <code>OneHotEncoder</code> output</li>
<li>Repeat the same process with new data</li>
</ol>
</div>
</div>
</div>
<p>This process is less than ideal, since repeating the same steps twice is both inefficient and error-prone. Not only that, but the complexity of this process will continue to increase as you preprocess additional features.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Problems with a manual approach:</strong></p>
<ul>
<li>Repeating steps is inefficient and error-prone</li>
<li>Complexity will increase</li>
</ul>
</div>
</div>
</div>
<p>In the next chapter, I’ll introduce you to the <code>ColumnTransformer</code> and <code>Pipeline</code> classes. We’ll use these two classes to accomplish our goal of adding Embarked and Sex to our model, but we’ll do it in a way that is both reliable and efficient.</p>
</section>
<section id="qa-when-should-i-use-transform-instead-of-fit_transform" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="qa-when-should-i-use-transform-instead-of-fit_transform"><span class="header-section-number">3.4</span> Q&amp;A: When should I use transform instead of fit_transform?</h2>
<p>Earlier in this chapter, we used the <code>fit_transform</code> method of <code>OneHotEncoder</code> to encode two categorical features. In this lesson, I’ll show you when it’s appropriate to just use the <code>transform</code> method instead of <code>fit_transform</code>. The example below will use <code>OneHotEncoder</code>, but the principles I’m teaching here apply the same way to all transformers.</p>
<p>We’ll start by creating a DataFrame of training data with just 1 categorical feature.</p>
<div id="cb81b200" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>demo_train <span class="op">=</span> pd.DataFrame({<span class="st">'letter'</span>:[<span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>, <span class="st">'B'</span>]})</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>demo_train</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="11">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">letter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>A</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>B</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>C</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>B</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Let’s run <code>fit_transform</code> on the entire DataFrame.</p>
<div id="cc2a76ae" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>ohe.fit_transform(demo_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="12">
<pre><code>array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.],
       [0., 1., 0.]])</code></pre>
</div>
</div>
<p>Recall that <code>fit_transform</code> is really 2 steps. During the first step, which is <code>fit</code>, the <code>OneHotEncoder</code> learns the 3 categories. During the second step, which is <code>transform</code>, the <code>OneHotEncoder</code> creates the feature matrix using those categories. It outputs a 4 by 3 array, since there are 4 samples and 3 categories.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Example of fit_transform on training data:</strong></p>
<ul>
<li><strong><code>fit</code>:</strong> Learn 3 categories (A, B, C)</li>
<li><strong><code>transform</code>:</strong> Create feature matrix with 3 columns</li>
</ul>
</div>
</div>
</div>
<p>Now, we’ll create a DataFrame of testing data. It contains the same feature, but that feature includes one less category.</p>
<div id="a10bc114" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>demo_test <span class="op">=</span> pd.DataFrame({<span class="st">'letter'</span>:[<span class="st">'A'</span>, <span class="st">'C'</span>, <span class="st">'A'</span>]})</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>demo_test</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">letter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>A</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>C</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>A</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>What would happen if we ran <code>fit_transform</code> on the testing data?</p>
<div id="0524bf79" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>ohe.fit_transform(demo_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>array([[1., 0.],
       [0., 1.],
       [1., 0.]])</code></pre>
</div>
</div>
<p>The output array only includes two columns, because the testing data only included two categories. The first column represents the A category, and the second column represents the C category.</p>
<p>This is problematic, because if we trained a model using the 3-column feature matrix, and then tried to make predictions on the 2-column feature matrix, it would error due to a shape mismatch. That makes sense because if you train a model such as logistic regression using 3 features, it will learn 3 coefficients, and it expects to use all 3 of those coefficients when making predictions.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Example of fit_transform on testing data:</strong></p>
<ul>
<li><strong><code>fit</code>:</strong> Learn 2 categories (A, C)</li>
<li><strong><code>transform</code>:</strong> Create feature matrix with 2 columns</li>
</ul>
</div>
</div>
</div>
<p>The solution is to run <code>fit_transform</code> on the training data, and only run <code>transform</code> on the testing data. Let’s take a look at the output arrays.</p>
<p>Notice that the categories are represented the same way in both arrays: The first column represents A, the second column represents B, and the third column represents C.</p>
<div id="aabfc0c9" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>ohe.fit_transform(demo_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.],
       [0., 1., 0.]])</code></pre>
</div>
</div>
<div id="ac0019ef" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>ohe.transform(demo_test)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="16">
<pre><code>array([[1., 0., 0.],
       [0., 0., 1.],
       [1., 0., 0.]])</code></pre>
</div>
</div>
<p>This happened because we only ran the <code>fit</code> method once, on the training data, and the <code>fit</code> method is when the <code>OneHotEncoder</code> learns the categories.</p>
<p>Then we ran the <code>transform</code> method twice, both on the training data and the testing data. Because we didn’t run the <code>fit</code> method on the testing data, the categories learned from the training data were applied to both the training and testing data. This is critically important because it means that both our training and testing feature matrices have 3 columns, and those 3 columns mean the same thing.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Correct process:</strong></p>
<ol type="1">
<li>Run <code>fit_transform</code> on training data:
<ul>
<li><strong><code>fit</code>:</strong> Learn 3 categories (A, B, C)</li>
<li><strong><code>transform</code>:</strong> Create feature matrix with 3 columns</li>
</ul></li>
<li>Run <code>transform</code> on testing data:
<ul>
<li><strong><code>transform</code>:</strong> Create feature matrix with 3 columns</li>
</ul></li>
</ol>
</div>
</div>
</div>
<p>In summary, when using any transformer, you will always use the <code>fit_transform</code> method on the training data and only the <code>transform</code> method on the testing data.</p>
</section>
<section id="sec-3-5" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="sec-3-5"><span class="header-section-number">3.5</span> Q&amp;A: What happens if the testing data includes a new category?</h2>
<p>In the previous lesson, we created this example DataFrame of training data.</p>
<div id="8d0af833" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>demo_train</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="17">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">letter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>A</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>B</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>C</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>B</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>When we passed that DataFrame to <code>fit_transform</code>, the output array included three columns.</p>
<div id="5c2be329" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>ohe.fit_transform(demo_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<pre><code>array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.],
       [0., 1., 0.]])</code></pre>
</div>
</div>
<p>We know from the <code>categories_</code> attribute that those columns represent the categories A, B, and C.</p>
<div id="b1bdcacc" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>ohe.categories_</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>[array(['A', 'B', 'C'], dtype=object)]</code></pre>
</div>
</div>
<p>Now we’ll create a new DataFrame of testing data that includes a category, D, which was not seen in the training data.</p>
<div id="d0be8b22" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>demo_test_unknown <span class="op">=</span> pd.DataFrame({<span class="st">'letter'</span>:[<span class="st">'A'</span>, <span class="st">'C'</span>, <span class="st">'D'</span>]})</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>demo_test_unknown</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">letter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>A</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>C</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>D</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>If you pass this new DataFrame to the <code>transform</code> method, it will throw an error because it doesn’t know how to represent the D category. It only knows how to represent the A, B, and C categories because those are the ones that were seen by the <code>OneHotEncoder</code> during the <code>fit</code> step.</p>
<div id="58567781" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>ohe.transform(demo_test_unknown)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="3aa91195" class="cell" data-execution_count="22">
<div class="cell-output cell-output-stdout">
<pre><code>ValueError: Found unknown categories ['D'] in column 0 during transform</code></pre>
</div>
</div>
<p>There are two possible solutions to this problem.</p>
<p>The first solution is to specify the categories manually to the <code>OneHotEncoder</code> when creating an instance.</p>
<div id="19984563" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>ohe <span class="op">=</span> OneHotEncoder(sparse<span class="op">=</span><span class="va">False</span>, categories<span class="op">=</span>[[<span class="st">'A'</span>, <span class="st">'B'</span>, <span class="st">'C'</span>, <span class="st">'D'</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then, when <code>fit_transform</code> is run on the training data, a column is reserved for each of the four categories.</p>
<div id="d775452e" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>ohe.fit_transform(demo_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>array([[1., 0., 0., 0.],
       [0., 1., 0., 0.],
       [0., 0., 1., 0.],
       [0., 1., 0., 0.]])</code></pre>
</div>
</div>
<p>As a result, the <code>transform</code> on the testing data will no longer error.</p>
<div id="14cf57e6" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>ohe.transform(demo_test_unknown)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>array([[1., 0., 0., 0.],
       [0., 0., 1., 0.],
       [0., 0., 0., 1.]])</code></pre>
</div>
</div>
<p>However, specifying the categories manually is only a useful solution if you know all possible categories that might ever appear in your data. But in the real world, you don’t always know the full set of categories ahead of time.</p>
<p>For example, there might be rare categories that aren’t present in your set of samples, or new categories might be added in the future. For example, if one of your categorical features was medical billing codes, you could imagine that new billing codes are added over time.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Why you might not know all possible categories:</strong></p>
<ul>
<li>Rare categories aren’t present in your set of samples</li>
<li>New categories are added later</li>
</ul>
</div>
</div>
</div>
<p>If you don’t know all possible categories, then the solution is to set the <code>handle_unknown</code> parameter of the <code>OneHotEncoder</code> to <code>'ignore'</code>, which overrides the default value of <code>'error'</code>.</p>
<div id="1731f8aa" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>ohe <span class="op">=</span> OneHotEncoder(sparse<span class="op">=</span><span class="va">False</span>, handle_unknown<span class="op">=</span><span class="st">'ignore'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s use the <code>fit_transform</code> method on our training data one more time. The output array includes three columns representing A, B, and C.</p>
<div id="192be76e" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>ohe.fit_transform(demo_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.],
       [0., 1., 0.]])</code></pre>
</div>
</div>
<p>Now, when you use the <code>transform</code> method on the testing data, the third sample is encoded as all zeros because D is an unknown category.</p>
<div id="ec875a85" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>ohe.transform(demo_test_unknown)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre><code>array([[1., 0., 0.],
       [0., 0., 1.],
       [0., 0., 0.]])</code></pre>
</div>
</div>
<p>Although this might seem strange, this is actually quite a reasonable approach since you don’t have any information from the training data about the relationship between the D category and the target value.</p>
<p>One limitation of this approach, however, is that all unknown categories will be encoded the same way, which means that an E value in the testing data would also be encoded as all zeros.</p>
<p>Here’s my overall advice:</p>
<ol type="1">
<li>When starting a project, keep the <code>handle_unknown</code> parameter set to its default value of <code>'error'</code> so that you’ll know if you are encountering new categories in your testing data.</li>
<li>If you do find that you’re encountering new categories, but you can determine the full set of categories through research, then define the categories manually when creating the <code>OneHotEncoder</code> instance.</li>
<li>If you can’t determine the full set of categories, then set the <code>handle_unknown</code> parameter to <code>'ignore'</code>. However, you should retrain your model as soon as possible using data that includes any new categories.</li>
</ol>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Advice for OneHotEncoder:</strong></p>
<ol type="1">
<li>Start with <code>handle_unknown</code> set to <code>'error'</code></li>
<li>If possible, specify the categories manually</li>
<li>If necessary, set <code>handle_unknown</code> to <code>'ignore'</code> and then retrain your model</li>
</ol>
</div>
</div>
</div>
</section>
<section id="sec-3-6" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="sec-3-6"><span class="header-section-number">3.6</span> Q&amp;A: Should I drop one of the one-hot encoded categories?</h2>
<p>Here’s the example training data that we’ve used in the past few lessons.</p>
<div id="70ffa21e" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>demo_train</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="28">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">letter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>A</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>B</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>C</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>B</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>And here’s the default one-hot encoding of this DataFrame.</p>
<div id="98f03c77" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>ohe.fit_transform(demo_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre><code>array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.],
       [0., 1., 0.]])</code></pre>
</div>
</div>
<p>When one-hot encoding, it’s somewhat common to drop the first column of the output array because it contains redundant information and because it avoids collinearity between features.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>You can drop the first column:</strong></p>
<ul>
<li>Contains redundant information</li>
<li>Avoids collinearity between features</li>
</ul>
</div>
</div>
</div>
<p>If you want to drop the first column, you can set the <code>OneHotEncoder</code>’s <code>drop</code> parameter to <code>'first'</code>, though this option only exists in scikit-learn version 0.21 and later. When you run the <code>fit_transform</code>, you can see that the output array contains 1 less column. However, the new encoding retains the same information, since each category is still represented by a unique code: 00 means “A”, 10 means “B”, and 01 means “C”.</p>
<div id="0e27bffe" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>ohe <span class="op">=</span> OneHotEncoder(sparse<span class="op">=</span><span class="va">False</span>, drop<span class="op">=</span><span class="st">'first'</span>)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>ohe.fit_transform(demo_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="30">
<pre><code>array([[0., 0.],
       [1., 0.],
       [0., 1.],
       [1., 0.]])</code></pre>
</div>
</div>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Decoding the output array (after dropping the first column):</strong></p>
<ul>
<li>0, 0 means “A”</li>
<li>1, 0 means “B”</li>
<li>0, 1 means “C”</li>
</ul>
</div>
</div>
</div>
<p>Dropping the first column will work regardless of the number of categories, but you’re only ever allowed to drop a single column. And it doesn’t actually matter which column you drop, though the convention is to drop the first column.</p>
<p>You’ve now seen that you can drop the first column, but the question is: Should you drop the first column? Here’s my advice.</p>
<p>If you know that perfectly collinear features will cause problems, such as when feeding the resulting data into a neural network or an unregularized regression, then it’s a good idea to drop the first column. However, for most scikit-learn models, perfectly collinear features will not cause any problems, and thus dropping the first column will not benefit the model.</p>
<p>There are also some significant downsides to dropping the first column that you need to be aware of:</p>
<ul>
<li>Dropping the first column is incompatible with ignoring unknown categories, which is the <code>handle_unknown='ignore'</code> option that we saw in the previous lesson, since the dropped category and unknown categories would both be encoded as all zeros. You are allowed to do this starting in scikit-learn 1.0, but I still don’t recommend it.</li>
<li>Dropping the first column can introduce bias into the model if you standardize your features, such as with <code>StandardScaler</code>, or if you use a regularized model, such as logistic regression, since the dropped category will be exempt from standardization and regularization.</li>
</ul>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Should you drop the first column?</strong></p>
<ul>
<li><strong>Advantages:</strong>
<ul>
<li>Useful if perfectly collinear features will cause problems (does not apply to most models)</li>
</ul></li>
<li><strong>Disadvantages:</strong>
<ul>
<li>Incompatible with <code>handle_unknown='ignore'</code></li>
<li>Introduces bias if you standardize features or use a regularized model</li>
</ul></li>
</ul>
</div>
</div>
</div>
<p>In summary, I recommend that you drop the first column only if you know that perfectly collinear features will cause problems, otherwise I don’t recommend dropping the first column.</p>
</section>
<section id="qa-how-do-i-encode-an-ordinal-feature" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="qa-how-do-i-encode-an-ordinal-feature"><span class="header-section-number">3.7</span> Q&amp;A: How do I encode an ordinal feature?</h2>
<p>Throughout this chapter, we used one-hot encoding to encode unordered categorical features, also known as nominal data. But how should you encode categorical features with an inherent logical ordering, also known as ordinal data? That’s the subject of this lesson.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Types of categorical data:</strong></p>
<ul>
<li>Unordered (nominal data)</li>
<li>Ordered (ordinal data)</li>
</ul>
</div>
</div>
</div>
<p>Let’s take a look at our Titanic DataFrame.</p>
<p>Pclass, which stands for passenger class, is an ordinal feature. Although it’s already numeric, the numbers 1, 2, and 3 represent the categories 1st class, 2nd class, and 3rd class. It’s considered ordinal data because there’s a logical ordering to the categories.</p>
<p>Our intuition is that there may be a relationship between Pclass values increasing and survival rate decreasing, because passengers in the lower-numbered classes may have gotten priority access to lifeboats.</p>
<div id="8a8000a8" class="cell" data-execution_count="32">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="31">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Survived</th>
<th data-quarto-table-cell-role="th">Pclass</th>
<th data-quarto-table-cell-role="th">Name</th>
<th data-quarto-table-cell-role="th">Sex</th>
<th data-quarto-table-cell-role="th">Age</th>
<th data-quarto-table-cell-role="th">SibSp</th>
<th data-quarto-table-cell-role="th">Parch</th>
<th data-quarto-table-cell-role="th">Ticket</th>
<th data-quarto-table-cell-role="th">Fare</th>
<th data-quarto-table-cell-role="th">Cabin</th>
<th data-quarto-table-cell-role="th">Embarked</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>0</td>
<td>3</td>
<td>Braund, Mr. Owen Harris</td>
<td>male</td>
<td>22.0</td>
<td>1</td>
<td>0</td>
<td>A/5 21171</td>
<td>7.2500</td>
<td>NaN</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1</td>
<td>1</td>
<td>Cumings, Mrs. John Bradley (Florence Briggs Th...</td>
<td>female</td>
<td>38.0</td>
<td>1</td>
<td>0</td>
<td>PC 17599</td>
<td>71.2833</td>
<td>C85</td>
<td>C</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1</td>
<td>3</td>
<td>Heikkinen, Miss. Laina</td>
<td>female</td>
<td>26.0</td>
<td>0</td>
<td>0</td>
<td>STON/O2. 3101282</td>
<td>7.9250</td>
<td>NaN</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1</td>
<td>1</td>
<td>Futrelle, Mrs. Jacques Heath (Lily May Peel)</td>
<td>female</td>
<td>35.0</td>
<td>1</td>
<td>0</td>
<td>113803</td>
<td>53.1000</td>
<td>C123</td>
<td>S</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>0</td>
<td>3</td>
<td>Allen, Mr. William Henry</td>
<td>male</td>
<td>35.0</td>
<td>0</td>
<td>0</td>
<td>373450</td>
<td>8.0500</td>
<td>NaN</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>0</td>
<td>3</td>
<td>Moran, Mr. James</td>
<td>male</td>
<td>NaN</td>
<td>0</td>
<td>0</td>
<td>330877</td>
<td>8.4583</td>
<td>NaN</td>
<td>Q</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>0</td>
<td>1</td>
<td>McCarthy, Mr. Timothy J</td>
<td>male</td>
<td>54.0</td>
<td>0</td>
<td>0</td>
<td>17463</td>
<td>51.8625</td>
<td>E46</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>0</td>
<td>3</td>
<td>Palsson, Master. Gosta Leonard</td>
<td>male</td>
<td>2.0</td>
<td>3</td>
<td>1</td>
<td>349909</td>
<td>21.0750</td>
<td>NaN</td>
<td>S</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8</td>
<td>1</td>
<td>3</td>
<td>Johnson, Mrs. Oscar W (Elisabeth Vilhelmina Berg)</td>
<td>female</td>
<td>27.0</td>
<td>0</td>
<td>2</td>
<td>347742</td>
<td>11.1333</td>
<td>NaN</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">9</td>
<td>1</td>
<td>2</td>
<td>Nasser, Mrs. Nicholas (Adele Achem)</td>
<td>female</td>
<td>14.0</td>
<td>1</td>
<td>0</td>
<td>237736</td>
<td>30.0708</td>
<td>NaN</td>
<td>C</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Thus if we were going to include Pclass in the model, we would keep the existing numeric encoding so that the model can learn the relationship between Pclass and Survived with a single feature. You could use one-hot encoding with Pclass instead, but the model wouldn’t be able to learn that relationship as effectively because that information would be spread out across three features.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Options for encoding Pclass:</strong></p>
<ul>
<li><strong>Ordinal encoding:</strong> Create 1 feature</li>
<li><strong>One-hot encoding:</strong> Create 3 features</li>
</ul>
</div>
</div>
</div>
<p>Let’s create an example DataFrame to see how to handle ordinal features that are stored as strings.</p>
<p>In this DataFrame, we have two ordinal features, Class and Size.</p>
<div id="9eb3258d" class="cell" data-execution_count="36">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>df_ordinal <span class="op">=</span> pd.DataFrame({<span class="st">'Class'</span>: [<span class="st">'third'</span>, <span class="st">'first'</span>, <span class="st">'second'</span>,</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>                                     <span class="st">'third'</span>],</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>                           <span class="st">'Size'</span>: [<span class="st">'S'</span>, <span class="st">'S'</span>, <span class="st">'L'</span>, <span class="st">'XL'</span>]})</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>df_ordinal</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="35">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Class</th>
<th data-quarto-table-cell-role="th">Size</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>third</td>
<td>S</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>first</td>
<td>S</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>second</td>
<td>L</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>third</td>
<td>XL</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>If you have ordinal data, you should use the <code>OrdinalEncoder</code> class to do the encoding. First, you import it from the <code>preprocessing</code> module. Then, you create an instance of <code>OrdinalEncoder</code>, and when you do so, you define the logical order of the categories.</p>
<p>We pass a list of lists to the <code>categories</code> parameter, in which the first inner list is the categories for the Class feature, and the second inner list is the categories for the Size feature. I put the two lists in that order because that is the order in which I’ll be passing the features to the <code>fit_transform</code> method.</p>
<p>One important note is that I included the “M” category for Size even though it wasn’t present in this DataFrame because I knew that it would occur in the dataset at some point.</p>
<div id="4cf26267" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> OrdinalEncoder</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>oe <span class="op">=</span> OrdinalEncoder(categories<span class="op">=</span>[[<span class="st">'first'</span>, <span class="st">'second'</span>, <span class="st">'third'</span>],</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>                                [<span class="st">'S'</span>, <span class="st">'M'</span>, <span class="st">'L'</span>, <span class="st">'XL'</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we pass the DataFrame to the <code>OrdinalEncoder</code>’s <code>fit_transform</code> method in order to do the encoding. You’ll notice that each input feature became a single feature in the output array.</p>
<div id="ee916506" class="cell" data-execution_count="38">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>oe.fit_transform(df_ordinal)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="37">
<pre><code>array([[2., 0.],
       [0., 0.],
       [1., 2.],
       [2., 3.]])</code></pre>
</div>
</div>
<p>For the Class feature, “first” was encoded as 0, “second” was encoded as 1, and “third” was encoded as 2.</p>
<p>For the Size feature, “S” was encoded as 0, “L” was encoded as 2, and “XL” was encoded as 3. And if “M” appears in the data at some point, it will be encoded as 1.</p>
<p>Again, we encoded each input feature as a single column so that the model can learn the relationship between the target and an increase or decrease in each feature.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Decoding the output array:</strong></p>
<ul>
<li><strong>First column:</strong>
<ul>
<li>0 means “first”</li>
<li>1 means “second”</li>
<li>2 means “third”</li>
</ul></li>
<li><strong>Second column:</strong>
<ul>
<li>0 means “S”</li>
<li>1 means “M”</li>
<li>2 means “L”</li>
<li>3 means “XL”</li>
</ul></li>
<li><strong>Example:</strong>
<ul>
<li>2, 0 means “third, S”</li>
</ul></li>
</ul>
</div>
</div>
</div>
<p>Let’s briefly contrast this with the output you would get if you used <code>OneHotEncoder</code> with these same two features.</p>
<p><code>OneHotEncoder</code> would create 7 columns in the output array, since Class has 3 categories and Size has 4 categories. These 7 columns contain the same information as the 2 columns output by OrdinalEncoder, but the model would have a comparatively harder time learning from the 7 columns since the information is expressed in a less compact form.</p>
<div id="9a028fbd" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>ohe <span class="op">=</span> OneHotEncoder(sparse<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>                    categories<span class="op">=</span>[[<span class="st">'first'</span>, <span class="st">'second'</span>, <span class="st">'third'</span>],</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>                                [<span class="st">'S'</span>, <span class="st">'M'</span>, <span class="st">'L'</span>, <span class="st">'XL'</span>]])</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>ohe.fit_transform(df_ordinal)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="38">
<pre><code>array([[0., 0., 1., 1., 0., 0., 0.],
       [1., 0., 0., 1., 0., 0., 0.],
       [0., 1., 0., 0., 0., 1., 0.],
       [0., 0., 1., 0., 0., 0., 1.]])</code></pre>
</div>
</div>
<p>Here’s a summary of my advice on this topic:</p>
<ol type="1">
<li>If you have an ordinal feature that’s already encoded numerically, then leave it as-is.</li>
<li>If you have an ordinal feature that’s stored as strings, then encode it using <code>OrdinalEncoder</code>.</li>
<li>If you have a nominal feature, then encode it using <code>OneHotEncoder</code>.</li>
</ol>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Advice for encoding categorical data:</strong></p>
<ul>
<li><strong>Ordinal feature stored as numbers:</strong> Leave as-is</li>
<li><strong>Ordinal feature stored as strings:</strong> Use <code>OrdinalEncoder</code></li>
<li><strong>Nominal feature:</strong> Use <code>OneHotEncoder</code></li>
</ul>
</div>
</div>
</div>
<p>In chapter 17, we’ll explore this topic further and see if there are cases in which you should diverge from this advice.</p>
<p>One final note about <code>OrdinalEncoder</code> is that unlike <code>OneHotEncoder</code>, it does not allow for new categories in the testing data that were not seen during training. However, that functionality is available beginning in scikit-learn version 0.24 using a <code>handle_unknown</code> parameter.</p>
</section>
<section id="qa-whats-the-difference-between-ordinalencoder-and-labelencoder" class="level2" data-number="3.8">
<h2 data-number="3.8" class="anchored" data-anchor-id="qa-whats-the-difference-between-ordinalencoder-and-labelencoder"><span class="header-section-number">3.8</span> Q&amp;A: What’s the difference between OrdinalEncoder and LabelEncoder?</h2>
<p>There are many similarities between the <code>OrdinalEncoder</code> and <code>LabelEncoder</code> classes, so in this lesson I’ll explain how they’re different and why you should be using <code>OrdinalEncoder</code>, not <code>LabelEncoder</code>.</p>
<p>The first main difference is that <code>OrdinalEncoder</code> allows you to define the order of the categories, whereas <code>LabelEncoder</code> does not. <code>LabelEncoder</code> simply uses the alphabetical order of the values you pass to it to determine which value to encode as 0, which value to encode as 1, and so on.</p>
<p>The second main difference is that <code>OrdinalEncoder</code> can be used to encode multiple features at once, whereas <code>LabelEncoder</code> can only encode one column of data at once.</p>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<table class="caption-top table">
<thead>
<tr class="header">
<th style="text-align: left;">&nbsp;</th>
<th style="text-align: center;"><strong>OrdinalEncoder</strong></th>
<th style="text-align: center;"><strong>LabelEncoder</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Can you define the category order?</strong></td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Can you encode multiple features?</strong></td>
<td style="text-align: center;">Yes</td>
<td style="text-align: center;">No</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<p>Because of these differences, <code>OrdinalEncoder</code> is much better suited than <code>LabelEncoder</code> for encoding ordinal features. In fact, <code>LabelEncoder</code> is only intended for the encoding of class labels, hence its name.</p>
<p>You might be asking why <code>LabelEncoder</code> even exists, given its limitations. There are two reasons:</p>
<ul>
<li>First, in older versions of scikit-learn, some classification models were not able to handle string-based labels. <code>LabelEncoder</code> was used to encode those strings as integers so that they could be passed to the model. That limitation has since been removed, and so all scikit-learn classifiers can now handle string-based labels. Therefore, you should never need to use <code>LabelEncoder</code> for encoding your class labels.</li>
<li>Second, also in order versions of scikit-learn, <code>OneHotEncoder</code> did not accept strings as input. Thus if you had categorical data stored as strings, you actually had to use <code>LabelEncoder</code> to encode the strings as integers before passing them to the <code>OneHotEncoder</code>. Again, that limitation has since been removed, and so you can pass string-based categorical data directly to <code>OneHotEncoder</code>.</li>
</ul>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Outdated uses for LabelEncoder:</strong></p>
<ul>
<li>Encoding string-based labels for some classifiers</li>
<li>Encoding string-based features for <code>OneHotEncoder</code></li>
</ul>
</div>
</div>
</div>
<p>Because of this legacy from older versions of scikit-learn, many people are familiar with <code>LabelEncoder</code> and thus use it to encode features. However, the best practice is to use <code>OrdinalEncoder</code> to encode ordinal features. In fact, it’s rare that you will ever need to use <code>LabelEncoder</code>, which is why I’m not using it in this book.</p>
</section>
<section id="qa-should-i-encode-numeric-features-as-ordinal-features" class="level2" data-number="3.9">
<h2 data-number="3.9" class="anchored" data-anchor-id="qa-should-i-encode-numeric-features-as-ordinal-features"><span class="header-section-number">3.9</span> Q&amp;A: Should I encode numeric features as ordinal features?</h2>
<p>Normally, when you have a continuous numeric feature such as Fare, you pass that feature directly to your Machine Learning model.</p>
<div id="0e5796d9" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>df[[<span class="st">'Fare'</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="39">
<div>


<table class="dataframe caption-top table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Fare</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>7.2500</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>71.2833</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>7.9250</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>53.1000</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>8.0500</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">5</td>
<td>8.4583</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">6</td>
<td>51.8625</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">7</td>
<td>21.0750</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">8</td>
<td>11.1333</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">9</td>
<td>30.0708</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>However, one strategy that is sometimes used with numeric features is to “discretize” or “bin” them into categorical features. In scikit-learn, we can do this using <code>KBinsDiscretizer</code>.</p>
<div id="eafc2c35" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> KBinsDiscretizer</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>When creating an instance of <code>KBinsDiscretizer</code>, you define the number of bins, the binning strategy, and the method used for encoding the result.</p>
<div id="a7ba15d9" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>kb <span class="op">=</span> KBinsDiscretizer(n_bins<span class="op">=</span><span class="dv">3</span>, strategy<span class="op">=</span><span class="st">'quantile'</span>, encode<span class="op">=</span><span class="st">'ordinal'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here’s the output when we pass the Fare feature to the <code>fit_transform</code> method.</p>
<p>Because we specified 3 bins, every sample has been assigned to bin 0 or 1 or 2. The smallest values were assigned to bin 0, the largest values were assigned to bin 2, and the values in between were assigned to bin 1. Thus, we’ve taken a continuous numeric feature and encoded it as an ordinal feature, and this ordinal feature could be passed to the model in place of the numeric feature.</p>
<div id="0a47c8ab" class="cell" data-execution_count="43">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>kb.fit_transform(df[[<span class="st">'Fare'</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="42">
<pre><code>array([[0.],
       [2.],
       [0.],
       [2.],
       [0.],
       [1.],
       [2.],
       [1.],
       [1.],
       [2.]])</code></pre>
</div>
</div>
<p>The obvious follow-up question is: Should we discretize our numeric features? Theoretically, discretization can benefit linear models by helping them to learn non-linear trends. However, my general recommendation is to not use discretization, for three main reasons:</p>
<ul>
<li>First, discretization removes all nuance from the data, which makes it harder for a model to learn the actual trends that are present in the data.</li>
<li>Second, discretization reduces the variation in the data, which makes it easier to find trends that don’t actually exist.</li>
<li>Third, any possible benefits of discretization are highly dependent on the parameters used with <code>KBinsDiscretizer</code>. Making those decisions by hand creates a risk of overfitting the training data, and making those decisions during a tuning process adds both complexity and processing time, and so neither of those options is particularly attractive to me.</li>
</ul>
<div class="callout callout-style-simple callout-note no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p><strong>Why not discretize numeric features?</strong></p>
<ul>
<li>Makes it harder to learn the actual trends</li>
<li>Makes it easier to discover non-existent trends</li>
<li>May result in overfitting</li>
</ul>
</div>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/mlbook\.dataschool\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
            // default icon
            link.classList.add("external");
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./ch02.html" class="pagination-link" aria-label="Review of the Machine Learning workflow">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Review of the Machine Learning workflow</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./ch04.html" class="pagination-link" aria-label="Improving your workflow with ColumnTransformer and Pipeline">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Improving your workflow with ColumnTransformer and Pipeline</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright © 2025 by Kevin Markham. All rights reserved.</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>